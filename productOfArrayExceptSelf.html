// Given an integer array nums, return an array answer such that answer[i] is
// equal to the product of all the elements of nums except nums[i].

// The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit
// integer.

// You must write an algorithm that runs in O(n) time and without using the
// division operation.

// Input: nums = [1,2,3,4]
// Output: [24,12,8,6]

// Input: nums = [-1,1,0,-3,3]
// Output: [0,0,9,0,0]

function productExceptSelf(nums: number[]): number[] {

  // NEW STRATEGY:
  // init answer array
  const answer: number[] = [];

  const numsProduct = nums.reduce((acc, curr) => acc * curr);

  let i = 0;
  while (answer.length < nums.length) {

    let j = 1;
    while (nums[i] * j < numsProduct) j++;

    answer.push(j);

  }

  return answer;
  // loop / recursive function, i

    // base case: answer.length === nums.length return answer;
    // new loop j
      // until result = numProduct, multiply nums[i] * j
      // push(j) into answer

  // return answer


  // OLD STRATEGY:
  // // init answer array
  // const answer: number[] = [];

  // // iterate through each number n in the nums
  // for (let n = 0; n < nums.length; n++) {
  //   // // find the prefix array (non-inclusive)
  //   // const prefix = nums.slice(0,n);
  //   // // find the suffix array (non-inclusive)
  //   // const suffix = nums.slice(n+1);

  //   // remove n from nums
  //   const newNums = [...nums];
  //   newNums.splice(n,1);
  //   console.log('newNums', newNums);

  //   // // combine prefix and suffix arrays
  //   // const otherNums: number[] = [...prefix, ...suffix];

  //   // // multiply them together
  //   const product = newNums.reduce((acc, curr) => {
  //     return acc * curr;
  //   });

  //   // // push result into answer array
  //   answer.push(product);

  // }

  // // return answer array
  // return answer;

};